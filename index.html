<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Trading Bot Dashboard</title>
    <style>
        /* --- Keep all your previous CSS styles --- */
        body { font-family: Arial, sans-serif; background: #f5f5f5; color: #333; }
        .container { max-width: 1200px; margin: 20px auto; padding: 20px; background: #fff; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        h2,h3,h4 { color: #555; margin-top: 0; margin-bottom: 15px; }
        .section { margin-bottom: 30px; padding-bottom: 20px; border-bottom: 1px solid #eee; }
        .section:last-child { border-bottom: none; }
        label { display: inline-block; width: 140px; font-weight: bold; margin-bottom: 8px; vertical-align: middle; }
        select, input[type=number], input[type=date], input[type=text], button { margin-bottom: 10px; padding: 8px 12px; border: 1px solid #ccc; border-radius: 4px; vertical-align: middle; box-sizing: border-box; }
        select { width: 220px; }
        input[type=number] { width: 90px; }
        input[type=date], input[type=text] { width: 190px; }
        button { background: #4CAF50; color: #fff; cursor: pointer; font-weight: bold; border: none; }
        button:hover { background: #45a049; }
        button:disabled { background: #ccc; cursor: not-allowed; }
        .run-controls, .view-controls { display: flex; flex-wrap: wrap; align-items: center; gap: 10px; margin-bottom: 15px; }
        #resultsDisplay { margin-top: 20px; background: #f9f9f9; padding: 0; border: none; border-radius: 4px; } /* Adjusted padding/border */
        #status-message { margin-top: 15px; font-weight: bold; min-height: 1.2em; text-align: center; padding: 10px; border-radius: 4px;}
        .status-running { background-color: #fffbe6; border: 1px solid #ffe58f; color: #fa8c16; }
        .status-success { background-color: #f6ffed; border: 1px solid #b7eb8f; color: #52c41a; }
        .status-error   { background-color: #fff1f0; border: 1px solid #ffa39e; color: #f5222d; }
        .status-idle    { background-color: #fafafa; border: 1px solid #d9d9d9; color: #888; }
        .tab-buttons { border-bottom: 1px solid #ccc; padding-left: 5px; margin-bottom: -1px; /* Overlap border */ }
        .tab-buttons button { background-color: #eee; border: 1px solid #ccc; padding: 10px 15px; cursor: pointer; transition: background-color 0.3s; border-radius: 4px 4px 0 0; margin-right: 2px; font-size: 1em; border-bottom: none; }
        .tab-buttons button.active { background-color: #fff; color: #3498db; border: 1px solid #ccc; border-bottom: 1px solid white; position: relative; top: 1px; font-weight: bold; }
        .tab-content { display: none; padding: 20px; border: 1px solid #ccc; border-top: none; border-radius: 0 4px 4px 4px; background-color: #fff; animation: fadeIn 0.5s; }
        .tab-content.active { display: block; }
        @keyframes fadeIn { from {opacity: 0;} to {opacity: 1;} }
        table.performance-table { border-collapse: collapse; width: 100%; margin-bottom: 20px; font-size: 0.9em; }
        th, td { border: 1px solid #ddd; padding: 8px 10px; text-align: right; white-space: nowrap; }
        th { background-color: #e9e9e9; color: #333; text-align: center; font-weight: bold; }
        tr:nth-child(even) { background-color: #f9f9f9; }
        tr.details-row:hover { background-color: #f1f1f1; } /* Hover for trade details only */
        .summary-card { border: 1px solid #eee; border-radius: 5px; padding: 15px; margin-bottom: 20px; background: #fff; }
        .summary-card p { margin: 5px 0; font-size: 0.95em;}
        .summary-card strong { display: inline-block; min-width: 120px; color: #555;}
        .trade-table-container { margin-top: 20px; max-height: 400px; overflow-y: auto; border-top: 1px solid #eee; padding-top: 15px; }
        .profit { color: green; } .loss { color: red; } .neutral{ color: #555; } /* Simplified PnL color */
    </style>
</head>
<body>
<div class="container">
    <h2>Trading Bot Backtester</h2>

    <div class="section">
        <h3>Run New Backtest</h3>
        <form id="backtestRunForm">
            <div class="run-controls">
                <p>Click "Run" to start a new backtest using default settings (all configured timeframes & strategies).</p>
                <button type="submit" id="runButton">Run Backtest</button>
                <span id="loadingIndicator" style="display:none;">‚è≥ Running Backtest...</span>
            </div>
        </form>
    </div>

     <div class="section">
        <h3>View Past Results</h3>
        <div class="view-controls">
            <label for="runSelector">Select Run ID:</label>
            <select id="runSelector" name="run_id">
                <option value="">-- Loading Runs --</option>
            </select>
            <button id="viewButton" disabled>View Results</button>
        </div>
    </div>

    <div id="status-message" class="status-idle">Select parameters or a past run.</div>

    <div id="resultsDisplay" style="display: none;">
        <h3>Results for Run ID: <span id="resultsRunId"></span></h3>
        <div id="resultsTabsContainer">
            </div>
    </div>

</div>
<script>
    // --- Get DOM Elements (remains same) ---
    const runForm = document.getElementById('backtestRunForm');
    const runButton = document.getElementById('runButton');
    const loadingIndicator = document.getElementById('loadingIndicator');
    const statusMessage = document.getElementById('status-message');
    const runSelector = document.getElementById('runSelector');
    const viewButton = document.getElementById('viewButton');
    const resultsDisplay = document.getElementById('resultsDisplay');
    const resultsRunId = document.getElementById('resultsRunId');
    const resultsTabsContainer = document.getElementById('resultsTabsContainer');
    let currentStatusCheckInterval = null;
    let currentRunData = null; // Store fetched data

    // --- Helper Functions (remain same) ---
    function updateStatus(message, type = 'idle', isRunning = false) { /* ... */ statusMessage.textContent = message; statusMessage.className = `status-${type}`; runButton.disabled = isRunning; loadingIndicator.style.display = isRunning ? 'inline' : 'none'; }
    function formatNum(v, d = 2, suffix = '', naVal = '-') { /* ... */ return (v != null && typeof v === 'number' && !isNaN(v)) ? v.toFixed(d) + suffix : naVal; }

    // --- Tab Handling (remains same) ---
    function openTab(evt, tabName) { /* ... */
         let i, tabcontent, tablinks; tabcontent = resultsTabsContainer.getElementsByClassName("tab-content"); for (i = 0; i < tabcontent.length; i++) { tabcontent[i].style.display = "none"; tabcontent[i].classList.remove("active"); } tablinks = resultsTabsContainer.getElementsByClassName("tab-button"); for (i = 0; i < tablinks.length; i++) { tablinks[i].classList.remove("active"); } let currentTab = document.getElementById(tabName); if (currentTab) { currentTab.style.display = "block"; currentTab.classList.add("active"); } else { console.warn(`Tab content ID '${tabName}' not found.`); } if (evt && evt.currentTarget) { evt.currentTarget.classList.add("active"); } else { for (i = 0; i < tablinks.length; i++) { if (tablinks[i].getAttribute('onclick') && tablinks[i].getAttribute('onclick').includes(`'${tabName}'`)) { tablinks[i].classList.add("active"); break; } } } }

    // --- Function to Populate Trade Table (Simplified) ---
    // No longer needs strategyName, populates the single table in the tab
    function populateTradeTable(timeframe) {
        const tableBody = document.getElementById(`tradeTableBody_${timeframe}`);
        // Access trades directly from the agent's results for this timeframe
        const trades = currentRunData?.timeframes?.[timeframe]?.trades_details || [];

        if (!tableBody || !currentRunData) {
             console.error("Cannot populate trade table for", timeframe);
             if(tableBody) tableBody.innerHTML = `<tr><td colspan="7" style="text-align:center;color:red">Error loading trades</td></tr>`;
             return;
        }
        tableBody.innerHTML = ""; // Clear previous

        if (trades.length > 0) {
            trades.forEach(t => {
                const row = document.createElement('tr');
                row.classList.add('details-row');
                const profitClass = t.PnL_Points == null ? 'neutral' : (t.PnL_Points >= 0 ? 'profit' : 'loss');
                const formatDt = (iso) => iso ? new Date(iso).toLocaleString('en-GB', { dateStyle: 'short', timeStyle: 'medium'}) : '-';
                const posClass = t.Position === 'long' ? 'profit' : (t.Position === 'short' ? 'loss' : 'neutral');

                row.innerHTML = `
                    <td style="text-align:left;" class="${posClass}">${t.Position || '-'}</td>
                    <td style="text-align:left;">${formatDt(t.EntryTime)}</td>
                    <td>${formatNum(t.EntryPrice)}</td>
                    <td style="text-align:left;">${formatDt(t.ExitTime)}</td>
                    <td>${formatNum(t.ExitPrice)}</td>
                    <td style="text-align:left;">${t.ExitReason || '-'}</td>
                    <td class="${profitClass}">${formatNum(t.PnL_Points)}</td>
                `;
                tableBody.appendChild(row);
            });
        } else {
            tableBody.innerHTML = `<tr><td colspan="7" style="text-align:center;color:#666">No trades executed by the agent</td></tr>`;
        }
    }

    // --- *** UPDATED Function to Build UI from JSON Data *** ---
    function buildResultsUI(data) {
        currentRunData = data; // Store globally
        resultsTabsContainer.innerHTML = ""; // Clear previous
        resultsRunId.textContent = data.run_id || "N/A";

        const timeframes = Object.keys(data.timeframes || {});
        if (timeframes.length === 0) { resultsTabsContainer.innerHTML = "<p>No timeframe data found.</p>"; return; }

        // 1. Create Tab Buttons
        const tabButtonsDiv = document.createElement('div');
        tabButtonsDiv.className = 'tab-buttons';
        resultsTabsContainer.appendChild(tabButtonsDiv);
        timeframes.forEach((tf, index) => {
            const button = document.createElement('button');
            button.className = `tab-button ${index === 0 ? 'active' : ''}`;
            button.textContent = tf;
            button.onclick = (event) => openTab(event, tf);
            tabButtonsDiv.appendChild(button);
        });

        // 2. Create Tab Content Divs
        timeframes.forEach((tf, index) => {
            const agentSummary = data.timeframes[tf]; // This IS the agent's result dict
            const tabContentDiv = document.createElement('div');
            tabContentDiv.id = tf;
            const winRateVal = agentSummary.win_rate;
            tabContentDiv.className = `tab-content ${index === 0 ? 'active' : ''}`;

            let contentHTML = `<h2>Results for Timeframe: ${tf}</h2>`;

            if (agentSummary && agentSummary.error){
                 contentHTML += `<p style="color:red">Error loading results: ${agentSummary.error}</p>`;
            } else if (agentSummary) { // Check if agentSummary exists and is not error
                // --- Metrics Section ---
                contentHTML += `<h3>Performance Summary (Agent)</h3><div class="summary-card">`;
                const pnlVal = agentSummary.total_pnl; // Access directly
                const winRateVal = agentSummary.win_rate;
                const tradesVal = agentSummary.trade_count;
                const pnlClass = pnlVal == null ? 'neutral' : (pnlVal >= 0 ? 'profit' : 'loss');
                contentHTML += `<p><strong>Total PnL (Points):</strong> <span class='${pnlClass}'>${formatNum(pnlVal)}</span></p>`;
                contentHTML += `<p><strong>Total Trades:</strong> ${tradesVal ?? '-'}</p>`;
                contentHTML += `<p><strong>Win Rate:</strong> ${formatNum(winRateVal, 2, '%')}</p>`;
                // Add other metrics here if they exist in agentSummary
                contentHTML += `</div>`;

                // --- Trade Details Section ---
                contentHTML += `<h3>Trade Details (Agent)</h3>`;
                const trades = agentSummary.trades_details || []; // Access directly
                // REMOVED Strategy Selector Dropdown
                contentHTML += `<div class="trade-table-container">
                    <table class="performance-table trade-details">
                         <thead><tr>
                             <th>Position</th><th>Entry Time</th><th>Entry Price</th>
                             <th>Exit Time</th><th>Exit Price</th><th>Exit Reason</th>
                             <th>PnL (Points)</th>
                          </tr></thead>
                         <tbody id="tradeTableBody_${tf}">
                            </tbody>
                    </table>
                </div>`;
            } else {
                 contentHTML += `<p>No data available for this timeframe.</p>`;
            } // End check for agentSummary content

            tabContentDiv.innerHTML = contentHTML;
            resultsTabsContainer.appendChild(tabContentDiv);

            // Populate the trade table for this tab AFTER adding content to DOM
             if (agentSummary && !agentSummary.error) {
                 setTimeout(() => populateTradeTable(tf), 0); // Populate trade table
             }

        }); // End timeframe loop

        resultsDisplay.style.display = 'block';
        // Ensure first tab content is displayed
        const firstActiveTab = resultsTabsContainer.querySelector('.tab-content.active');
        if(firstActiveTab) firstActiveTab.style.display = 'block';

    } // End buildResultsUI


    // --- fetchAndDisplayResults (remains same, calls buildResultsUI) ---
    async function fetchAndDisplayResults(runId) {
        if (!runId) { resultsDisplay.style.display = 'none'; return; }
        updateStatus(`Workspaceing results for run ${runId}...`, 'running', runButton.disabled);
        resultsTabsContainer.innerHTML = '<p>Loading results...</p>';
        resultsDisplay.style.display = 'block';
       
        try {
            const resp = await fetch(`/results/${runId}`);
            if (!resp.ok) { let errorMsg = `HTTP ${resp.status}: ${resp.statusText}`; try { const errJson = await resp.json(); errorMsg = errJson.error || errorMsg; } catch(e){} throw new Error(errorMsg); }
            const resultsData = await resp.json();
            if (resultsData.error) throw new Error(resultsData.error);
            if (!resultsData.timeframes) throw new Error("No timeframe data found in response.");
            buildResultsUI(resultsData); // Build the UI dynamically
            if (!statusMessage.className.includes('error')) { updateStatus(`Results loaded for run ${runId}.`, 'success'); }
           } 
        // Inside the fetchAndDisplayResults function in index.html <script> tag

        
        catch (err) { // <--- Start of catch block
            console.error(`Error fetching results for ${runId}:`, err); // Log the actual error object
            resultsTabsContainer.innerHTML = `<p style="color:red;">Error loading results: ${err.message}</p>`; // Display error message from err object
            // Use err.message, DO NOT use resp here
            updateStatus(`Error loading results for ${runId}: ${err.message}`, 'error');
        } finally { // <--- Start of finally block
             // This part is okay, it fetches status independently
             fetch('/status').then(r=>r.json()).then(s=> {
                 if (!s.running) runButton.disabled = false;
             });
        }
    } // <--- End of fetchAndDisplayResults function
    

    // --- pollStatus (remains same) ---
    function pollStatus(runId) { /* ... */
        if (currentStatusCheckInterval) { clearInterval(currentStatusCheckInterval); } updateStatus(`Checking status for run ${runId}...`, 'running', true);
        currentStatusCheckInterval = setInterval(async () => { try { const resp = await fetch('/status'); if (!resp.ok) { clearInterval(currentStatusCheckInterval); updateStatus(`Error checking status: ${resp.statusText}`, 'error'); return; } const statusData = await resp.json(); if (statusData.run_id === runId) { if (statusData.running) { updateStatus(statusData.message || `Running run ${runId}...`, 'running', true); } else { clearInterval(currentStatusCheckInterval); if (statusData.error) { updateStatus(`Run ${runId} failed: ${statusData.error}`, 'error'); } else { updateStatus(`Run ${runId} complete. Fetching results...`, 'success'); fetchAndDisplayResults(runId); } } } else if (!statusData.running) { clearInterval(currentStatusCheckInterval); if (statusMessage.textContent.includes(runId) && statusMessage.className.includes('running')) { updateStatus(`Run ${runId} status unknown or completed earlier.`, 'idle'); } } } catch (err) { console.error("Error polling status:", err); clearInterval(currentStatusCheckInterval); updateStatus(`Error polling status: ${err.message}`, 'error'); } }, 3000);
    }

    // --- Event Listeners (remain same) ---
    runForm.addEventListener('submit', async (e) => { /* ... */
         e.preventDefault(); if (runButton.disabled) return; updateStatus('Starting new backtest run...', 'running', true); resultsDisplay.style.display = 'none'; resultsTabsContainer.innerHTML = ''; try { const resp = await fetch('/start_backtest', { method: 'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({}) }); const respText = await resp.text(); if (!resp.ok) { let err = respText; try {err = JSON.parse(err).error || err;} catch(ex){} throw new Error(`HTTP ${resp.status}: ${err}`); } const startData = JSON.parse(respText); updateStatus(`Run ${startData.run_id} submitted. Processing...`, 'running', true); pollStatus(startData.run_id); loadRuns(); } catch (err) { console.error("Error starting backtest:", err); updateStatus(`Error starting backtest: ${err.message}`, 'error', false); }
    });
    viewButton.addEventListener('click', () => { const selectedRunId = runSelector.value; fetchAndDisplayResults(selectedRunId); });
    runSelector.addEventListener('change', () => { viewButton.disabled = !runSelector.value; if (!runSelector.value) { resultsDisplay.style.display = 'none'; } });

    // --- Load Past Runs (remains same) ---
    async function loadRuns() { /* ... */
         try { const resp = await fetch('/runs'); if (!resp.ok) throw new Error(`HTTP ${resp.status}: ${resp.statusText}`); const runIds = await resp.json(); const currentVal = runSelector.value; runSelector.innerHTML = '<option value="">-- Select a Past Run --</option>'; if (runIds && runIds.length > 0) { runIds.forEach(runId => { const option = document.createElement('option'); option.value = runId; option.textContent = runId; if(runId === currentVal) option.selected = true; runSelector.appendChild(option); }); runSelector.disabled = false; } else { runSelector.innerHTML = '<option value="">-- No Past Runs Found --</option>'; runSelector.disabled = true; } viewButton.disabled = !runSelector.value; } catch (err) { console.error("Error loading runs:", err); runSelector.innerHTML = `<option value="">Error loading runs</option>`; runSelector.disabled = true; viewButton.disabled = true; }
    }

    // --- Initial Load (remains same) ---
    updateStatus("Idle. Ready to run backtest or view past results.", 'idle'); loadRuns(); fetch('/status').then(r=>r.json()).then(s=> { if (s.running && s.run_id) { pollStatus(s.run_id); } else { updateStatus("Idle.", 'idle', false); } });

</script>
</body>
</html>